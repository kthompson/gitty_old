using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Gitty.Core.TreeWalk
{
    /// <summary>
    /// Walks a Git tree (directory) in Git sort order.
    /// <p>
    /// A new iterator instance should be positioned on the first entry, or at eof.
    /// Data for the first entry (if not at eof) should be available immediately.
    /// </p>
    /// <p>
    /// Implementors must walk a tree in the Git sort order, which has the following
    /// odd sorting:
    /// <ol>
    ///  <li>A.c</li>
    ///  <li>A/c</li>
    ///  <li>A0c</li>
    /// </ol>
    /// </p>
    /// <p>
    ///     In the second item, <code>A</code> is the name of a subtree and
    ///     <code>c</code> is a file within that subtree. The other two items are files
    ///     in the root level tree.
    ///     <see ref="CanonicalTreeParser"/>
    /// </p>
    /// </summary>
    public abstract class AbstractTreeIterator
    {
        static int DEFAULT_PATH_SIZE = 128;

        /// <summary>
        /// A dummy object id buffer that matches the zero ObjectId.
        /// </summary>
        protected static readonly byte[] zeroid = new byte[Constants.ObjectId.Length];

        /// <summary>
        /// Iterator for the parent tree; null if we are the root iterator. 
        /// </summary>
        AbstractTreeIterator parent;

        /// <summary>
        /// The iterator this current entry is path equal to.
        /// </summary>
        AbstractTreeIterator matches;


        /// <summary>
        /// Number of entries we moved forward to force a D/F conflict match.
        /// 
        /// <see ref="NameConflictTreeWalk"/>
        /// </summary>
        int matchShift;

        /// <summary>
        /// Mode bits for the current entry.
        /// <p>
        /// A numerical value from FileMode is usually faster for an iterator to
        /// obtain from its data source so this is the preferred representation.
        /// <see ref="FileMode"/>
        /// </p>
        /// </summary>
        protected int mode;

        /**
         * Path buffer for the current entry.
         * <p>
         * This buffer is pre-allocated at the start of walking and is shared from
         * parent iterators down into their subtree iterators. The sharing allows
         * the current entry to always be a full path from the root, while each
         * subtree only needs to populate the part that is under their control.
         * </p>
         */
        protected byte[] path;

        /**
         * Position within {@link #path} this iterator starts writing at.
         * <p>
         * This is the first offset in {@link #path} that this iterator must
         * populate during {@link #next}. At the root level (when {@link #parent}
         * is null) this is 0. For a subtree iterator the index before this position
         * should have the value '/'.</p>
         */
        protected int pathOffset;

        /**
         * Total length of the current entry's complete path from the root.
         * <p>
         * This is the number of bytes within {@link #path} that pertain to the
         * current entry. Values at this index through the end of the array are
         * garbage and may be randomly populated from prior entries.
         */
        protected int pathLen;


        /// <summary>
        /// Create a new iterator with no parent.
        /// </summary>
        protected AbstractTreeIterator()
        {
            parent = null;
            path = new byte[DEFAULT_PATH_SIZE];
            pathOffset = 0;
        }


        /**
	     * Create a new iterator with no parent and a prefix.
	     * <p>
	     * The prefix path supplied is inserted in front of all paths generated by
	     * this iterator. It is intended to be used when an iterator is being
	     * created for a subsection of an overall repository and needs to be
	     * combined with other iterators that are created to run over the entire
	     * repository namespace.
	     *
	     * @param prefix
	     *            position of this iterator in the repository tree. The value
	     *            may be null or the empty string to indicate the prefix is the
	     *            root of the repository. A trailing slash ('/') is
	     *            automatically appended if the prefix does not end in '/'.
	     */
        protected AbstractTreeIterator(string prefix)
        {
            parent = null;

            if (!string.IsNullOrEmpty(prefix))
            {
                byte[] b;

                b = Constants.Encoding.GetBytes(prefix);
                pathLen = b.Length;
                path = new byte[Math.Max(DEFAULT_PATH_SIZE, pathLen + 1)];

                Array.Copy(b, path, pathLen);
                if (path[pathLen - 1] != '/')
                    path[pathLen++] = (byte)'/';
                pathOffset = pathLen;
            }
            else
            {
                path = new byte[DEFAULT_PATH_SIZE];
                pathOffset = 0;
            }
        }





        /**
         * Create a new iterator with no parent and a prefix.
         * <p>
         * The prefix path supplied is inserted in front of all paths generated by
         * this iterator. It is intended to be used when an iterator is being
         * created for a subsection of an overall repository and needs to be
         * combined with other iterators that are created to run over the entire
         * repository namespace.
         *
         * @param prefix
         *            position of this iterator in the repository tree. The value
         *            may be null or the empty array to indicate the prefix is the
         *            root of the repository. A trailing slash ('/') is
         *            automatically appended if the prefix does not end in '/'.
         */
        protected AbstractTreeIterator(byte[] prefix)
        {
            parent = null;

            if (prefix != null && prefix.Length > 0)
            {
                pathLen = prefix.Length;
                path = new byte[Math.Max(DEFAULT_PATH_SIZE, pathLen + 1)];
                Array.Copy(prefix, 0, path, 0, pathLen);
                if (path[pathLen - 1] != '/')
                    path[pathLen++] = (byte)'/';
                pathOffset = pathLen;
            }
            else
            {
                path = new byte[DEFAULT_PATH_SIZE];
                pathOffset = 0;
            }
        }



        /**
         * Create an iterator for a subtree of an existing iterator.
         * 
         * @param p
         *            parent tree iterator.
         */
        protected AbstractTreeIterator(AbstractTreeIterator p)
        {
            parent = p;
            path = p.path;
            pathOffset = p.pathLen + 1;
            try
            {
                path[pathOffset - 1] = (byte)'/';
            }
            catch (IndexOutOfRangeException e)
            {
                GrowPath(p.pathLen);
                path[pathOffset - 1] = (byte)'/';
            }
        }

        /**
         * Create an iterator for a subtree of an existing iterator.
         * <p>
         * The caller is responsible for setting up the path of the child iterator.
         *
         * @param p
         *            parent tree iterator.
         * @param childPath
         *            path array to be used by the child iterator. This path must
         *            contain the path from the top of the walk to the first child
         *            and must end with a '/'.
         * @param childPathOffset
         *            position within <code>childPath</code> where the child can
         *            insert its data. The value at
         *            <code>childPath[childPathOffset-1]</code> must be '/'.
         */
        protected AbstractTreeIterator(AbstractTreeIterator p, byte[] childPath, int childPathOffset)
        {
            parent = p;
            path = childPath;
            pathOffset = childPathOffset;
        }

        /**
         * Grow the path buffer larger.
         * 
         * @param len
         *            number of live bytes in the path buffer. This many bytes will
         *            be moved into the larger buffer.
         */
        protected void GrowPath(int len)
        {
            byte[] n = new byte[path.Length << 1];
            Array.Copy(path, 0, n, 0, len);
            for (AbstractTreeIterator p = this; p != null; p = p.parent)
                p.path = n;
        }


        /**
         * Compare the path of this current entry to another iterator's entry.
         * 
         * @param p
         *            the other iterator to compare the path against.
         * @return -1 if this entry sorts first; 0 if the entries are equal; 1 if
         *         p's entry sorts first.
         */
        public int pathCompare(AbstractTreeIterator p)
        {
            return pathCompare(p, p.mode);
        }

        int pathCompare(AbstractTreeIterator p, int pMode)
        {
            byte[] a = path;
            byte[] b = p.path;
            int aLen = pathLen;
            int bLen = p.pathLen;
            int cPos;

            // Its common when we are a subtree for both parents to match;
            // when this happens everything in path[0..cPos] is known to
            // be equal and does not require evaluation again.
            //
            cPos = AlreadyMatch(this, p);

            for (; cPos < aLen && cPos < bLen; cPos++)
            {
                int cmp = (a[cPos] & 0xff) - (b[cPos] & 0xff);
                if (cmp != 0)
                    return cmp;
            }

            if (cPos < aLen)
                return (a[cPos] & 0xff) - LastPathChar(pMode);
            if (cPos < bLen)
                return LastPathChar(mode) - (b[cPos] & 0xff);
            return LastPathChar(mode) - LastPathChar(pMode);
        }

        private static int AlreadyMatch(AbstractTreeIterator a, AbstractTreeIterator b)
        {
            while (true)
            {
                AbstractTreeIterator ap = a.parent;
                AbstractTreeIterator bp = b.parent;
                if (ap == null || bp == null)
                    return 0;
                if (ap.matches == bp.matches)
                    return a.pathOffset;
                a = ap;
                b = bp;
            }
        }

        private static int LastPathChar(int mode)
        {
            return FileMode.Tree.Equals(mode) ? '/' : '\0';
        }



        /**
         * Check if the current entry of both iterators has the same id.
         * <p>
         * This method is faster than {@link #getEntryObjectId()} as it does not
         * require copying the bytes out of the buffers. A direct {@link #idBuffer}
         * compare operation is performed.
         * 
         * @param otherIterator
         *            the other iterator to test against.
         * @return true if both iterators have the same object id; false otherwise.
         */
        public bool IdEqual(AbstractTreeIterator otherIterator)
        {
            return ObjectId.Equals(IdBuffer(), IdOffset(), otherIterator.IdBuffer(), otherIterator.IdOffset());
        }



        /**
         * Get the object id of the current entry.
         * 
         * @return an object id for the current entry.
         */
        public ObjectId GetEntryObjectId()
        {
            return ObjectId.FromRaw(IdBuffer(), IdOffset());
        }

        /**
         * Obtain the ObjectId for the current entry.
         *
         * @param out
         *            buffer to copy the object id into.
         */
        public void GetEntryObjectId(MutableObjectId mo)
        {
            mo.FromRaw(IdBuffer(), IdOffset());
        }

        /** @return the file mode of the current entry. */
        public FileMode GetEntryFileMode()
        {
            return FileMode.FromBits(mode);
        }

        /** @return path of the current entry, as a string. */
        public String GetEntryPathString()
        {
            throw new NotImplementedException();
            //return TreeWalk.pathOf(this);
        }


        /**
         * Get the byte array buffer object IDs must be copied out of.
         * <p>
         * The id buffer contains the bytes necessary to construct an ObjectId for
         * the current entry of this iterator. The buffer can be the same buffer for
         * all entries, or it can be a unique buffer per-entry. Implementations are
         * encouraged to expose their private buffer whenever possible to reduce
         * garbage generation and copying costs.
         * 
         * @return byte array the implementation stores object IDs within.
         * @see #getEntryObjectId()
         */
        public abstract byte[] IdBuffer();

        /**
         * Get the position within {@link #idBuffer()} of this entry's ObjectId.
         * 
         * @return offset into the array returned by {@link #idBuffer()} where the
         *         ObjectId must be copied out of.
         */
        public abstract int IdOffset();


        /**
         * Create a new iterator for the current entry's subtree.
         * <p>
         * The parent reference of the iterator must be <code>this</code>,
         * otherwise the caller would not be able to exit out of the subtree
         * iterator correctly and return to continue walking <code>this</code>.
         * 
         * @param repo
         *            repository to load the tree data from.
         * @return a new parser that walks over the current subtree.
         * @throws IncorrectObjectTypeException
         *             the current entry is not actually a tree and cannot be parsed
         *             as though it were a tree.
         * @throws IOException
         *             a loose object or pack file could not be read.
         */
        public abstract AbstractTreeIterator CreateSubtreeIterator(Repository repo);

        /**
         * Create a new iterator for the current entry's subtree.
         * <p>
         * The parent reference of the iterator must be <code>this</code>, otherwise
         * the caller would not be able to exit out of the subtree iterator
         * correctly and return to continue walking <code>this</code>.
         *
         * @param repo
         *            repository to load the tree data from.
         * @param idBuffer
         *            temporary ObjectId buffer for use by this method.
         * @param curs
         *            window cursor to use during repository access.
         * @return a new parser that walks over the current subtree.
         * @throws IncorrectObjectTypeException
         *             the current entry is not actually a tree and cannot be parsed
         *             as though it were a tree.
         * @throws IOException
         *             a loose object or pack file could not be read.
         */
        public AbstractTreeIterator CreateSubtreeIterator(Repository repo, MutableObjectId idBuffer)
        {
            return CreateSubtreeIterator(repo);
        }



        /**
         * Is this tree iterator positioned on its first entry?
         * <p>
         * An iterator is positioned on the first entry if <code>back(1)</code>
         * would be an invalid request as there is no entry before the current one.
         * <p>
         * An empty iterator (one with no entries) will be
         * <code>first() &amp;&amp; eof()</code>.
         *
         * @return true if the iterator is positioned on the first entry.
         */
        public abstract bool First { get; }



        /**
         * Is this tree iterator at its EOF point (no more entries)?
         * <p>
         * An iterator is at EOF if there is no current entry.
         * 
         * @return true if we have walked all entries and have none left.
         */
        public abstract bool EndOfIterator { get; }

        /**
         * Move to next entry, populating this iterator with the entry data.
         * <p>
         * The delta indicates how many moves forward should occur. The most common
         * delta is 1 to move to the next entry.
         * <p>
         * Implementations must populate the following members:
         * <ul>
         * <li>{@link #mode}</li>
         * <li>{@link #path} (from {@link #pathOffset} to {@link #pathLen})</li>
         * <li>{@link #pathLen}</li>
         * </ul>
         * as well as any implementation dependent information necessary to
         * accurately return data from {@link #idBuffer()} and {@link #idOffset()}
         * when demanded.
         *
         * @param delta
         *            number of entries to move the iterator by. Must be a positive,
         *            non-zero integer.
         * @throws CorruptObjectException
         *             the tree is invalid.
         */
        public abstract void MoveNext(int delta);

        /**
         * Move to prior entry, populating this iterator with the entry data.
         * <p>
         * The delta indicates how many moves backward should occur.The most common
         * delta is 1 to move to the prior entry.
         * <p>
         * Implementations must populate the following members:
         * <ul>
         * <li>{@link #mode}</li>
         * <li>{@link #path} (from {@link #pathOffset} to {@link #pathLen})</li>
         * <li>{@link #pathLen}</li>
         * </ul>
         * as well as any implementation dependent information necessary to
         * accurately return data from {@link #idBuffer()} and {@link #idOffset()}
         * when demanded.
         * 
         * @param delta
         *            number of entries to move the iterator by. Must be a positive,
         *            non-zero integer.
         * @throws CorruptObjectException
         *             the tree is invalid.
         */
        public abstract void MoveBack(int delta);

        /**
         * Advance to the next tree entry, populating this iterator with its data.
         * <p>
         * This method behaves like <code>seek(1)</code> but is called by
         * {@link TreeWalk} only if a {@link TreeFilter} was used and ruled out the
         * current entry from the results. In such cases this tree iterator may
         * perform special behavior.
         *
         * @throws CorruptObjectException
         *             the tree is invalid.
         */
        public void Skip()
        {
            MoveNext(1);
        }


        /**
         * Indicates to the iterator that no more entries will be read.
         * <p>
         * This is only invoked by TreeWalk when the iteration is aborted early due
         * to a {@link org.spearce.jgit.errors.StopWalkException} being thrown from
         * within a TreeFilter.
         */
        public void StopWalk()
        {
            // Do nothing by default.  Most iterators do not care.
        }
    }
}
